<!-- Компонент состоит из трех основних блоков -->

<!-- Опциональный API -->
<script>
// блок script при использовании опционального API всегда возвращает дефолтный объект
export default {
  // в данном объекте указывают следующие опции.

  data() {
    return { dataValueA: 1, dataValueB: 2 }
  }, // ФУНКЦИЯ которая возвращает объект который Vue сделает реактивным состоянием. То есть state.

  //   props: [], // опция в которой мы принимаем переданые реквезиты елемента от родительского елемента.
  //   props: ['size', 'myMessage'], // Пропсы могут приниматся как масив строк (простая форма).
  // Или как объект (полная форма) в котором ключ ето имя реквизита, а значення – тип реквизита (функция конструктора) или розширеные параметры.
  props: {
    propsNameA: Number, // проверка типа.
    propsNameB: {
      // при полной форме каждый реквизит может дополнительно определить следующие параметры.
      type: Number, // проверка типа. Может быть string, Number, Boolean, Array, Object, Date, Function, Symbol
      default: 0, // значение по умолчанию.
      required: true, // определяет обязательное наличие даного реквизита.
      validator: (value) => {
        return value >= 0
      } // функция проверки.
    }
  },

  // объект в которм объявляються исчесляемые свойства компонента тоесть те которые можна посчитать на основании данных state в виде полей (ето не метод и не функция он никогда не может принимать аргументы и его не нужно вызывать) которые вызываются только при езменении свойств стейта что участвуют в вычислении нового свойства то есть те свойства от которых зависит computed.  Vue кеширует результаты вычисления данных свойств. computed НЕ изменяет состояние и возвращает свойство которое ипользуется в шаблоне.
  computed: {
    count() {
      return this.$store.state.count
    },
    propertyName() {
      return this.a * 2
    }, // свойство которое можно только прочитать
    propertyNameWithGetAndSet: {
      // свойство которое можно прочитать и записать.
      get() {
        return this.a + 1
      },
      set(v) {
        this.a = v - 1
      }
    }
  },

  methods: {
    methodName() {
      this.dataValue += 1
    },
    eventName() {
      // создание пользовательского события в methods.
      this.$emit('event-name')
    }
  }, // объект в которм объявляються методы для работи с компонентом. Логика Действие!

  watch: { dataValueA() {}, dataValueB() {} }, // объект в которм объявляються callback ФУНКЦИИ для для наблюдения за свойствами state. Функции виполняются в случае если наблюдаемое свойство изменяется. Логика Когда? => То!

  //   emits: ['eventName'], // ❓❓❓ масив или объект в котором объявляются пользоватильские событыя генерируимые компонентом.

  emits: {
    eventNameA: null,
    eventNameB: () => {
      return true || false
    } // functionCallback
  },

  expose: ['', '', ''], // масив строк для явного указания свойств которые будут доступны в родительском компоненте $parent, $root.

  directives: {} // Для создания кастомных директив доступных локально в компоненте.
}
</script>

<template>
  <!-- в етом блоке описывают HTML шаблон компонента -->
  <div>{{ count }}</div>
</template>

<style scoped>
/* в етом блоке описывают стили для текущего компонента компонента */
/* scoped - значит что стиль применятся только к текущему компоненту */
</style>

<!-- Композиционный API 
 <script setup>
defineProps(['', ''])
import { ref, onMounted, reactive } from 'vue'

// реактивний стан
const state = reactive({ count: 0 })

// реактивний стан
const count = ref(0)

// функції, що змінюють стан і запускають оновлення
function increment() {
  count.value++
}

// хуки життєвого циклу
onMounted(() => {
  console.log(`The initial count is ${count.value}.`)
})
</script>
 -->
